diff -ruN dpkg-1.16.3.orig/configure dpkg-1.16.3/configure
--- dpkg-1.16.3.orig/configure	2012-04-27 02:11:23.000000000 -0600
+++ dpkg-1.16.3/configure	2012-06-23 18:28:36.000000000 -0600
@@ -10827,10 +10827,6 @@
 
     LDFLAGS=$(echo "$LDFLAGS" | sed -e "s/ -Wl,-O[0-9]*\b//g")
 
-else
-
-    LDFLAGS="$LDFLAGS -Wl,-O1"
-
 fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking dpkg cpu type" >&5
diff -ruN dpkg-1.16.3.orig/dpkg-deb/build.c dpkg-1.16.3/dpkg-deb/build.c
--- dpkg-1.16.3.orig/dpkg-deb/build.c	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/dpkg-deb/build.c	2012-06-26 15:28:21.000000000 -0600
@@ -299,6 +299,14 @@
   NULL
 };
 
+/* FINK LOCAL begin */
+/* List of Fink fields */
+static const char *fink_fields[] = {
+  "BuildDependsOnly",
+  NULL
+};
+/* FINK LOCAL end */
+
 static const char private_prefix[] = "Private-";
 
 static bool
@@ -306,6 +314,13 @@
 {
   const char **known;
 
+  /* FINK LOCAL begin */
+  /* Fink fields are okay */
+  for (known = fink_fields; *known; known++)
+    if (strcasecmp(field->name, *known) == 0)
+      return true;
+  /* FINK LOCAL end */
+
   /* Always accept fields starting with a private field prefix. */
   if (strncasecmp(field->name, private_prefix, strlen(private_prefix)) == 0)
     return true;
diff -ruN dpkg-1.16.3.orig/dpkg-split/queue.c dpkg-1.16.3/dpkg-split/queue.c
--- dpkg-1.16.3.orig/dpkg-split/queue.c	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/dpkg-split/queue.c	2012-06-23 20:23:20.000000000 -0600
@@ -45,7 +45,7 @@
 #include "dpkg-split.h"
 
 /*
- * The queue, by default located in /var/lib/dpkg/parts/, is a plain
+ * The queue, by default located in @FINKPREFIX@/var/lib/dpkg/parts/, is a plain
  * directory with one file per part.
  *
  * Each part is named “<md5sum>.<maxpartlen>.<thispartn>.<maxpartn>”,
diff -ruN dpkg-1.16.3.orig/dselect/Makefile.am dpkg-1.16.3/dselect/Makefile.am
--- dpkg-1.16.3.orig/dselect/Makefile.am	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/dselect/Makefile.am	2012-06-23 20:07:34.000000000 -0600
@@ -8,7 +8,7 @@
 AM_CPPFLAGS = \
 	-DLOCALEDIR=\"$(localedir)\" \
 	-DADMINDIR=\"$(admindir)\" -DLIBDIR=\"$(pkglibdir)\" \
-	-DLOCALLIBDIR=\"/usr/local/lib/dpkg\" \
+	-DLOCALLIBDIR=\"@FINKPREFIX@/lib/dpkg\" \
 	-idirafter $(top_srcdir)/lib/compat \
 	-iquote $(builddir) \
 	-I$(top_builddir) \
diff -ruN dpkg-1.16.3.orig/dselect/Makefile.in dpkg-1.16.3/dselect/Makefile.in
--- dpkg-1.16.3.orig/dselect/Makefile.in	2012-04-27 02:11:24.000000000 -0600
+++ dpkg-1.16.3/dselect/Makefile.in	2012-06-24 10:09:37.000000000 -0600
@@ -314,7 +314,7 @@
 AM_CPPFLAGS = \
 	-DLOCALEDIR=\"$(localedir)\" \
 	-DADMINDIR=\"$(admindir)\" -DLIBDIR=\"$(pkglibdir)\" \
-	-DLOCALLIBDIR=\"/usr/local/lib/dpkg\" \
+	-DLOCALLIBDIR=\"@FINKPREFIX@/local/lib/dpkg\" \
 	-idirafter $(top_srcdir)/lib/compat \
 	-iquote $(builddir) \
 	-I$(top_builddir) \
@@ -789,7 +789,7 @@
 curkeys.$(OBJEXT): curkeys.h
 curkeys.h: $(srcdir)/keyoverride $(srcdir)/mkcurkeys.pl
 	$(AM_V_GEN) cursesfile=`echo '#include "dselect-curses.h"' | \
-		$(CPP) -I$(top_builddir) -I $(srcdir) - | \
+		$(CPP) -I$(top_builddir) -I $(srcdir) -I@FINKPREFIX@/include - | \
 		grep 'curses.h' | head -n 1 | \
 		sed -e 's/^[^"]*"//; s/".*$$//'`; \
 	if [ "$$cursesfile" = "" ]; then \
diff -ruN dpkg-1.16.3.orig/dselect/dselect-curses.h dpkg-1.16.3/dselect/dselect-curses.h
--- dpkg-1.16.3.orig/dselect/dselect-curses.h	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/dselect/dselect-curses.h	2012-06-24 09:44:08.000000000 -0600
@@ -26,7 +26,7 @@
 #undef ERR
 
 #if defined(HAVE_NCURSESW_NCURSES_H)
-#include <ncursesw/ncurses.h>
+#include <ncursesw/curses.h>
 #elif defined(HAVE_NCURSES_NCURSES_H)
 #include <ncurses/ncurses.h>
 #elif defined(HAVE_NCURSES_H)
diff -ruN dpkg-1.16.3.orig/dselect/dselect.h dpkg-1.16.3/dselect/dselect.h
--- dpkg-1.16.3.orig/dselect/dselect.h	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/dselect/dselect.h	2012-06-23 18:29:53.000000000 -0600
@@ -33,7 +33,7 @@
 
 #include "dselect-curses.h"
 
-#define DSELECT		"dselect"
+#define DSELECT		"@FINKPREFIX@/bin/dselect"
 
 #define TOTAL_LIST_WIDTH 180
 #define MAX_DISPLAY_INFO 120
diff -ruN dpkg-1.16.3.orig/dselect/main.cc dpkg-1.16.3/dselect/main.cc
--- dpkg-1.16.3.orig/dselect/main.cc	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/dselect/main.cc	2012-06-23 20:10:30.000000000 -0600
@@ -57,6 +57,12 @@
 #include <dpkg/dpkg-db.h>
 #include <dpkg/options.h>
 
+/* FINK LOCAL begin */
+#include <sys/utsname.h>
+#include <CoreFoundation/CoreFoundation.h>
+static void finkinit();
+/* FINK LOCAL end */
+
 #include "dselect.h"
 #include "bindings.h"
 #include "pkglist.h"
@@ -507,6 +513,173 @@
   return urqr_quitmenu;
 }
 
+/* FINK LOCAL begin */
+extern "C" {
+struct FinkVirtualPkgs {
+  struct FinkVirtualPkgs *next;
+  char *pkgname;
+  struct versionrevision version;
+};
+
+struct FinkVirtualPkgs *fink_virt_pkg = NULL;
+}
+static void finkinit()
+{
+  FILE *virt_pkg_stream = NULL;
+  struct stat sb;
+  struct FinkVirtualPkgs *pkg;
+  char name[256];
+  char version[256];
+  char revision[256];
+  unsigned int  epoch;
+  Boolean status;
+  SInt32 errorCode;
+  CFURLRef fileURL = NULL;
+  CFDataRef resourceData = NULL;
+  CFPropertyListRef propertyList = NULL;    CFStringRef string;
+  static char buffer[256];  // This is static, to ensure the buffer stays around
+  static struct utsname ver;  // This is static, to ensure the buffer stays around
+
+  // Set PERL5LIB for the scripts to use. This is necessary because some
+  // package scripts use Dpkg.pm and it's in a "non-standard" Fink location.
+  {
+    char *perl5lib     = getenv("PERL5LIB");
+    size_t perl5lib_s  = 0;
+    if( perl5lib != NULL )
+      perl5lib_s       = strlen( perl5lib );
+    const char *perl5lib_add = ":@FINKPREFIX@/lib/perl5";
+    char *perl5lib_new = (char*)malloc(perl5lib_s + strlen(perl5lib_add) + 1);
+    char *perl5lib_set = perl5lib_new;
+    if( perl5lib_s > 0 )
+      perl5lib_set = stpcpy( perl5lib_set, perl5lib );
+    perl5lib_set = stpcpy( perl5lib_set, perl5lib_add );
+    perl5lib_set[0] = '\0';
+    setenv( "PERL5LIB", perl5lib_new, 1 );
+    free( perl5lib_new );
+  }
+
+  if (0 == stat("@FINKPREFIX@/bin/fink-virtual-pkgs", &sb))
+  {
+    virt_pkg_stream =popen("@FINKPREFIX@/bin/fink-virtual-pkgs --dpkg","r");
+    if (virt_pkg_stream)
+    {
+      while (fscanf(virt_pkg_stream,"%s\t%u\t%s\t%s\n",name,&epoch,version, revision) == 4)
+      {
+        pkg = (struct FinkVirtualPkgs *)malloc(sizeof(struct FinkVirtualPkgs));
+        if (pkg)
+        {
+          pkg->next = fink_virt_pkg;
+          pkg->pkgname = strdup(name);
+          pkg->version.epoch = epoch;
+          pkg->version.version = strdup(version);
+          pkg->version.revision = strdup(revision);
+          /* Quick and simple sanity check */
+          if ((NULL != pkg->pkgname) && (0 != strlen(pkg->pkgname)) &&
+              (NULL != pkg->version.version) && (0 != strlen(pkg->version.version)) &&
+              (NULL != pkg->version.revision) && (0 != strlen(pkg->version.revision)))
+          {
+            /* We are leaking here if something fails the sanity check above */
+            fink_virt_pkg = pkg;
+          }
+        }
+      }
+      if (pclose(virt_pkg_stream))
+      {
+        /* The fink-virtual-pkgs script returned a non zero exit status *
+         * clean up and try the old way.                                */
+        while(NULL != fink_virt_pkg)
+        {
+          pkg = fink_virt_pkg;
+          if (NULL != pkg->pkgname) free(pkg->pkgname);
+          if (NULL != pkg->version.version) free((void*)pkg->version.version);
+          if (NULL != pkg->version.revision) free((void*)pkg->version.revision);
+          fink_virt_pkg = pkg->next;
+          free(pkg);
+        }
+      }
+    }
+  }
+  if (NULL == fink_virt_pkg)
+  {
+    /* Determine system version */
+    /* TODO - should maybe check if this is really Darwin? */
+    if (!uname(&ver)) {
+        pkg = (struct FinkVirtualPkgs *)malloc(sizeof(struct FinkVirtualPkgs));
+        if (pkg) {
+        pkg->next = fink_virt_pkg;
+        pkg->pkgname = strdup("darwin");
+        pkg->version.epoch = 0;
+        pkg->version.version = ver.release;
+        pkg->version.revision = NULL;
+        fink_virt_pkg = pkg;
+        }
+    }
+
+    /* Check whether this is Mac OS X, and which version of it */
+
+    fileURL = CFURLCreateWithFileSystemPath( NULL,
+      CFSTR("/System/Library/CoreServices/SystemVersion.plist"),
+      kCFURLPOSIXPathStyle,
+      false );
+    if (!fileURL)
+    goto BAIL;
+
+    /* Read the XML */
+    status = CFURLCreateDataAndPropertiesFromResource(
+      NULL,
+      fileURL,
+      &resourceData,
+      NULL,
+      NULL,
+      &errorCode);
+    if (!status || errorCode != 0)
+    goto BAIL;
+
+    /* Reconstitute the dictionary using the XML data. */
+    propertyList = CFPropertyListCreateFromXMLData( NULL,
+      resourceData,
+      kCFPropertyListImmutable,
+      &string);
+    if (!propertyList)
+    goto BAIL;
+
+    /* Try to read the system version from it. */
+    status = CFDictionaryGetValueIfPresent(
+      (CFDictionaryRef)propertyList,
+      (const void*)CFSTR("ProductVersion"),
+      (const void**)&string);
+    if (!status)
+    goto BAIL;
+
+    /* Convert into a C string */
+    status = CFStringGetCString( string,
+      buffer,
+      sizeof(buffer),
+      kCFStringEncodingISOLatin1);
+    if (!status)
+    goto BAIL;
+    pkg = (struct FinkVirtualPkgs *)malloc(sizeof(struct FinkVirtualPkgs));
+    if (pkg)
+    {
+      pkg->next = fink_virt_pkg;
+      pkg->pkgname = strdup("macosx");
+      pkg->version.epoch = 0;
+      pkg->version.version = buffer;
+      pkg->version.revision = NULL;
+      fink_virt_pkg = pkg;
+    }
+  BAIL:
+    // Release all of the CF objects we're responsible for.
+    if (fileURL)
+    CFRelease(fileURL);
+    if (resourceData)
+    CFRelease(resourceData);
+    if (propertyList)
+    CFRelease(propertyList);
+  }
+}
+/* FINK LOCAL end */
+
 static void
 dselect_catch_fatal_error()
 {
@@ -521,6 +694,10 @@
   bindtextdomain(DSELECT, LOCALEDIR);
   textdomain(DSELECT);
 
+  /* FINK LOCAL begin */
+  finkinit();
+  /* FINK LOCAL end */
+
   dpkg_set_progname(DSELECT);
 
   push_error_context_func(dselect_catch_fatal_error, print_fatal_error, 0);
diff -ruN dpkg-1.16.3.orig/dselect/methods/Debian/Dselect/Ftp.pm dpkg-1.16.3/dselect/methods/Debian/Dselect/Ftp.pm
--- dpkg-1.16.3.orig/dselect/methods/Debian/Dselect/Ftp.pm	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/dselect/methods/Debian/Dselect/Ftp.pm	2012-06-23 20:06:56.000000000 -0600
@@ -57,12 +57,12 @@
 }
 
 sub view_mirrors {
-  if (-f '/usr/lib/dpkg/methods/ftp/README.mirrors.txt') {
-    system('pager', '/usr/lib/dpkg/methods/ftp/README.mirrors.txt');
-  } elsif (-f '/usr/lib/dpkg/methods/ftp/README.mirrors.txt.gz') {
-    system('gzip -dc /usr/lib/dpkg/methods/ftp/README.mirrors.txt.gz | pager');
+  if (-f '@FINKPREFIX@/lib/dpkg/methods/ftp/README.mirrors.txt') {
+    system('less', '@FINKPREFIX@/lib/dpkg/methods/ftp/README.mirrors.txt');
+  } elsif (-f '@FINKPREFIX@/lib/dpkg/methods/ftp/README.mirrors.txt.gz') {
+    system('gzip -dc @FINKPREFIX@/lib/dpkg/methods/ftp/README.mirrors.txt.gz | pager');
   } else {
-    print "/usr/lib/dpkg/methods/ftp/README.mirrors.txt(.gz): file not found.\n";
+    print "@FINKPREFIX@/lib/dpkg/methods/ftp/README.mirrors.txt(.gz): file not found.\n";
   }
 }
 
diff -ruN dpkg-1.16.3.orig/dselect/methods/disk/setup dpkg-1.16.3/dselect/methods/disk/setup
--- dpkg-1.16.3.orig/dselect/methods/disk/setup	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/dselect/methods/disk/setup	2012-06-23 20:23:03.000000000 -0600
@@ -6,7 +6,7 @@
 option=$3
 
 cd "$vardir/methods/disk"
-tp=/var/run/ddm$$
+tp=@FINKPREFIX@/var/run/ddm$$
 
 iarch=`dpkg --admindir $vardir --print-architecture`
 
diff -ruN dpkg-1.16.3.orig/dselect/methods/ftp/install dpkg-1.16.3/dselect/methods/ftp/install
--- dpkg-1.16.3.orig/dselect/methods/ftp/install	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/dselect/methods/ftp/install	2012-06-23 20:05:18.000000000 -0600
@@ -13,8 +13,7 @@
 use vars qw(%config $ftp);
 #use diagnostics;
 
-use lib '/usr/lib/perl5/Debian';
-use lib '/usr/share/perl5/Debian';
+use lib '@FINKPREFIX@/lib/perl5/Debian';
 
 eval q{
     use Net::FTP;
diff -ruN dpkg-1.16.3.orig/dselect/methods/ftp/setup dpkg-1.16.3/dselect/methods/ftp/setup
--- dpkg-1.16.3.orig/dselect/methods/ftp/setup	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/dselect/methods/ftp/setup	2012-06-23 20:22:46.000000000 -0600
@@ -13,8 +13,7 @@
 use vars qw(%config);
 #use diagnostics;
 
-use lib '/usr/lib/perl5/Debian';
-use lib '/usr/share/perl5/Debian';
+use lib '@FINKPREFIX@/lib/perl5/Debian';
 
 eval 'use Net::FTP;';
 if ($@) {
@@ -72,7 +71,7 @@
 You must supply an ftp site, use of passive mode, username, password,
 path to the debian directory,list of distributions you are interested
 in and place to download the binary package files to (relative to
-/var/lib/dpkg/methods/ftp). You can add as much sites as you like. Later
+@FINKPREFIX@/var/lib/dpkg/methods/ftp). You can add as much sites as you like. Later
 entries will always override older ones.
 
 Supply "?" as a password to be asked each time you connect.
diff -ruN dpkg-1.16.3.orig/dselect/methods/ftp/update dpkg-1.16.3/dselect/methods/ftp/update
--- dpkg-1.16.3.orig/dselect/methods/ftp/update	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/dselect/methods/ftp/update	2012-06-23 20:05:46.000000000 -0600
@@ -12,8 +12,7 @@
 
 #use diagnostics;
 
-use lib '/usr/lib/perl5/Debian';
-use lib '/usr/share/perl5/Debian';
+use lib '@FINKPREFIX@/lib/perl5/Debian';
 
 eval 'use Net::FTP;';
 if ($@) {
diff -ruN dpkg-1.16.3.orig/dselect/methods/multicd/install dpkg-1.16.3/dselect/methods/multicd/install
--- dpkg-1.16.3.orig/dselect/methods/multicd/install	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/dselect/methods/multicd/install	2012-06-23 20:22:15.000000000 -0600
@@ -172,7 +172,7 @@
 Perhaps you downloaded it with an unexpected name, or something.
 In any case, you must find the file(s) and then either place it with
 the correct filename(s) (as listed in the Packages.cd file or in
-/var/lib/dpkg/available) and rerun the installation, or upgrade the
+@FINKPREFIX@/var/lib/dpkg/available) and rerun the installation, or upgrade the
 package by using `dpkg --install --auto-deconfigure'\'' by hand.
 
 ";
diff -ruN dpkg-1.16.3.orig/dselect/pkgdepcon.cc dpkg-1.16.3/dselect/pkgdepcon.cc
--- dpkg-1.16.3.orig/dselect/pkgdepcon.cc	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/dselect/pkgdepcon.cc	2012-06-23 21:20:17.000000000 -0600
@@ -203,6 +203,17 @@
   return 2;
 }
 
+/* FINK LOCAL begin */
+extern "C" {
+struct FinkVirtualPkgs {
+  struct FinkVirtualPkgs *next;
+  char *pkgname;
+  struct versionrevision version;
+};
+extern struct FinkVirtualPkgs *fink_virt_pkg;
+}
+/* FINK LOCAL end */
+
 int packagelist::resolvedepcon(dependency *depends) {
   perpackagestate *best, *fixbyupgrade;
   deppossi *possi, *provider;
@@ -370,6 +381,30 @@
   int would;
   pkginfo::pkgwant want= pkginfo::want_purge;
 
+  /* FINK LOCAL begin */
+  {
+    int interestingwarnings;
+    struct varbuf oemsgs;
+    struct FinkVirtualPkgs *virt_pkg = NULL;
+    varbuf_init(&oemsgs, 1024);
+    interestingwarnings= 0;
+    virt_pkg = fink_virt_pkg;
+    while (virt_pkg)
+    {
+      if (0==strcmp(possi->ed->name,virt_pkg->pkgname)) {
+        // Maybe use dbg_general instead of dbg_depcon?
+        debug(dbg_depcon,"Found package : %s from VirtPackages.pm, depended by %s\n",virt_pkg->pkgname, possi->ed->name);
+        if (versionsatisfied3(&virt_pkg->version,&possi->version,possi->verrel))
+        {
+          return 1;
+        }
+      }
+      virt_pkg = virt_pkg->next;
+    }
+    varbuf_destroy(&oemsgs);
+  }
+  /* FINK LOCAL end */
+
   if (possi->ed->pkg.clientdata) {
     want = possi->ed->pkg.clientdata->selected;
     would = would_like_to_install(want, &possi->ed->pkg);
diff -ruN dpkg-1.16.3.orig/fink/install-info.sh dpkg-1.16.3/fink/install-info.sh
--- dpkg-1.16.3.orig/fink/install-info.sh	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.16.3/fink/install-info.sh	2012-06-25 12:39:56.000000000 -0600
@@ -0,0 +1,40 @@
+#!/bin/sh
+#
+# Wrapper to the GNU's install-info, to be compatible with the one that used to
+# be packaged by dpkg on Debian.
+#
+# written by Norbert Preining, this is not copyrightable ;-)
+# Small textual modifications for Fink by Sjors Gielen, july 2011
+#
+set -e
+
+if [ -z "$DPKG_RUNNING_VERSION" ] ; then
+  # it seems we are running from outside a maintainer script, so give a
+  # warning and call ginstall-info without anything else
+  if [ -f @FINKPREFIX@/bin/ginstall-info ]; then
+    echo "This is not dpkg install-info anymore, but GNU install-info" >&2
+    ginstall-info "$@"
+  else
+    echo "GNU install-info not found, fallback to system install-info" >&2
+    /usr/bin/install-info "$@"
+  fi
+else
+  # we are running from a maintainer script, simply ignore the call
+  # since we have trigger support and people should rebuild their
+  # package with new debhelper which does not add calls to install-info
+  # Do not complain if called with "--remove" or "--remove-exactly",
+  # as these are used in old packages' prerm scripts (see #546165)
+  while [ -n "$1" ]; do
+    case "$1" in
+      --remove|--remove-exactly)
+        exit 0
+        ;;
+      *)
+        shift
+        ;;
+    esac
+  done
+  echo "Ignoring install-info call, infofiles will be installed automatically." >&2
+  # Don't give this warning, for now it's expected in Fink
+  #echo "The package $DPKG_MAINTSCRIPT_PACKAGE should be rebuilt with new debhelper to get trigger support" >&2
+fi
diff -ruN dpkg-1.16.3.orig/fink/md5sum dpkg-1.16.3/fink/md5sum
--- dpkg-1.16.3.orig/fink/md5sum	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.16.3/fink/md5sum	2012-06-23 18:54:06.000000000 -0600
@@ -0,0 +1,313 @@
+#!/usr/bin/perl
+use strict;
+use warnings;
+
+## md5sum wrapper for Mac md5 tool ##
+# This wrapper should be installed in bin/md5sum. Since dpkg 1.10, md5sum was
+# removed, this script is intended to replace it for fink systems.
+#
+# Written by Sjors Gielen, licensed under the same license as dpkg, the
+# GNU General Public License version 2.
+
+my $md5_bin = "/sbin/md5";
+my $check_mode = 0;
+my $quiet = 0;
+my $warn  = 0;
+my $return = 0;
+my @files;
+
+read_args(@ARGV);
+
+if( @files == 0 )
+{
+  push @files, "-";
+}
+
+if( $check_mode )
+{
+  # `md5` doesn't have a check mode, so we have to implement it ourselves
+  run_check_mode( @files );
+  exit $return;
+}
+
+if( $quiet || $warn )
+{
+  print STDERR <<"NOCHECKMODE";
+$0: the --status, --warn and -w options are meaningful only when verifying checksums
+Try `md5sum --help' for more information.
+NOCHECKMODE
+  exit $return;
+}
+
+my $stdin_done = 0;
+for my $file( @files )
+{
+  if( $file eq "-" and $stdin_done )
+  {
+    # second - is empty, so md5sum is of the empty string
+    print "d41d8cd98f00b204e9800998ecf8427e  -\n";
+    next;
+  }
+
+  my $checksum = checksum_for( $file );
+  if( !$checksum ) {
+    # error was already printed
+    next;
+  }
+
+  # the old md5sum, nor md5, understand binary mode, so...
+  print "$checksum  $file\n";
+
+  if( $file eq "-" )
+  {
+    $stdin_done = 1;
+  }
+}
+
+exit;
+
+sub help_and_exit()
+{
+  print <<"HELP";
+Usage: $0 [OPTION] [FILE]...
+Print or check MD5 (128-bit) checksums.
+With no FILE, or when FILE is -, read standard input.
+This md5sum is a wrapper around Mac's md5. If you can use md5 instead, please
+do, since this script is likely to be removed at some point.
+
+  -b, --binary            no difference on Mac platforms
+  -c, --check             read MD5 sums from the FILEs and check them
+  -t, --text              no difference on Mac platforms
+
+The following two options are useful only when verifying checksums:
+      --status            don't output anything, status code shows success
+  -w, --warn              warn about improperly formatted checksum lines
+
+      --help     display this help and exit
+      --version  output version information and exit
+
+The sums are computed as described in RFC 1321.  When checking, the input
+should be a former output of this program.  The default mode is to print
+a line with checksum, a character indicating type (`*' for binary, ` ' for
+text), and name for each FILE.
+
+Report bugs to <http://fink.sourceforge.net>.
+HELP
+  exit;
+}
+
+sub version_and_exit
+{
+  print <<"VERSION";
+md5sum (Fink md5sum) 1.0
+Copyright (C) 2010 Sjors Gielen
+This wrapper should be installed in bin/md5sum. Since dpkg 1.10, md5sum was
+removed, this script is intended to replace it for fink systems.
+License from dpkg: GNU GPL version 2.
+This is free software: you are free to change and redistribute it.
+There is NO WARRENTY, to the extent permitted by law.
+
+Written by Sjors Gielen.
+VERSION
+  exit;
+}
+
+sub read_args
+{
+  my $no_opts = 0;
+  for(@_)
+  {
+    if( !$no_opts and /^--(.*)$/ )
+    {
+      my $opt = $1;
+      if( $opt eq "help" )
+      {
+        help_and_exit();
+      }
+      elsif( $opt eq "version" )
+      {
+        version_and_exit();
+      }
+      elsif( $opt eq "binary" or $opt eq "text" )
+      {
+        # ignore
+      }
+      elsif( $opt eq "check" )
+      {
+        $check_mode = 1;
+      }
+      elsif( $opt eq "status" )
+      {
+        $quiet = 1;
+      }
+      elsif( $opt eq "warn" )
+      {
+        $warn = 1;
+      }
+      elsif( $opt eq "" )
+      {
+        $no_opts = 1;
+      }
+      else
+      {
+        print STDERR <<"HELPMSG";
+$0: unrecognised option `--$opt'
+Try `$0 --help' for more information.
+HELPMSG
+        exit;
+      }
+    }
+    elsif( !$no_opts and /^-(.+)$/ )
+    {
+      my @opts = split //, $1;
+      for(@opts) {
+        if( $_ eq "b" or $_ eq "t" )
+        {
+          # ignore
+        }
+        elsif( $_ eq "c" )
+        {
+          $check_mode = 1;
+        }
+        elsif( $_ eq "w" )
+        {
+          $warn = 1;
+        }
+        elsif( $_ eq "" )
+        {
+          # - here is just STDIN
+          push @files, '-';
+        }
+        else
+        {
+          print STDERR <<"ERRORMSG";
+$0: invalid option -- $_
+Try `md5sum --help' for more information.
+ERRORMSG
+          exit;
+        }
+      }
+    }
+    else
+    {
+      push @files, $_;
+    }
+  }
+}
+
+sub checksum_for
+{
+  my ($file) = @_;
+  my $sum;
+  if( $file eq "-" )
+  {
+    # read from stdin
+    $sum = `$md5_bin -p`;
+    1 while(chomp $sum);
+    # take only the last line, that's the checksum
+    $sum = (split /\n/, $sum)[-1];
+    return $sum;
+  }
+
+  # try to open the file to get the system error ourselves
+  eval {
+    open my $f, $file or die "$!\n";
+    close $f;
+  };
+  if( $@ ) {
+    print STDERR "$0: $file: $@";
+    $return = 1;
+    return "";
+  }
+
+  $sum = `$md5_bin -q "$file"`;
+  1 while(chomp $sum);
+  return $sum;
+}
+
+sub run_check_mode
+{
+  my @files = @_;
+  my $read_stdin = 0;
+  my $f;
+
+  for my $md5file( @files )
+  {
+    eval { open $f, $md5file or die $! };
+    if( $@ )
+    {
+      print STDERR "$0: $md5file: $@\n";
+      next;
+    }
+
+    my $lines = 0;
+    my $actual_lines = 0;
+    my $valid = 0;
+    my $errors = 0;
+    while(<$f>) {
+      my $line = $_;
+      $actual_lines++;
+
+      # check this line
+      my ($sum, $file) = $line =~ /^([0-9a-fA-F]{32}) (?: |\*)(.+)$/;
+      if( !defined($sum) || !defined($file)) {
+        if( $warn && $line !~ /^#/ )
+        {
+          warn "$0: $md5file: $actual_lines: improperly formatted MD5 checksum line\n";
+        }
+        next;
+      }
+
+      $lines++;
+      my $checksum = checksum_for($file);
+      if( !$checksum )
+      {
+        if( !$quiet )
+        {
+          print "$file: FAILED open or read\n";
+        }
+        $errors++;
+      }
+      elsif( lc($checksum) eq lc($sum) )
+      {
+        if( !$quiet )
+        {
+          print "$file: OK\n";
+        }
+        $valid++;
+      }
+      else
+      {
+        $return = 1;
+        if( !$quiet )
+        {
+          print "$file: FAILED\n";
+        }
+      }
+    }
+
+    close $f;
+    if( $lines == 0 )
+    {
+      warn "$0: $md5file: no properly formatted MD5 checksum lines found\n";
+      $return = 1;
+    }
+    if( $errors > 0 )
+    {
+      my $s = $lines == 1 ? "" : "s";
+      if( !$quiet )
+      {
+        warn "$0: WARNING: $errors of $lines listed file$s could not be read\n";
+      }
+    }
+    if( $valid < ($lines-$errors) )
+    {
+      my $checksums = $lines - $errors;
+      my $nomatch = $checksums - $valid;
+      if( !$quiet )
+      {
+        warn "$0: WARNING: $nomatch of $checksums computed checksums did NOT match\n";
+      }
+    }
+  }
+}
diff -ruN dpkg-1.16.3.orig/lib/dpkg/dpkg.h dpkg-1.16.3/lib/dpkg/dpkg.h
--- dpkg-1.16.3.orig/lib/dpkg/dpkg.h	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/lib/dpkg/dpkg.h	2012-06-23 20:09:35.000000000 -0600
@@ -94,19 +94,19 @@
 #define MAXUPDATES         250
 
 #define DEFAULTSHELL        "sh"
-#define DEFAULTPAGER        "pager"
+#define DEFAULTPAGER        "less"
 
 #define MD5HASHLEN           32
 #define MAXTRIGDIRECTIVE     256
 
-#define BACKEND		"dpkg-deb"
-#define SPLITTER	"dpkg-split"
-#define DPKGQUERY	"dpkg-query"
-#define DPKGDIVERT	"dpkg-divert"
-#define DPKGSTAT	"dpkg-statoverride"
-#define DPKGTRIGGER	"dpkg-trigger"
-#define DPKG		"dpkg"
-#define DEBSIGVERIFY	"/usr/bin/debsig-verify"
+#define BACKEND		"@FINKPREFIX@/bin/dpkg-deb"
+#define SPLITTER	"@FINKPREFIX@/bin/dpkg-split"
+#define DPKGQUERY	"@FINKPREFIX@/bin/dpkg-query"
+#define DPKGDIVERT	"@FINKPREFIX@/bin/dpkg-divert"
+#define DPKGSTAT	"@FINKPREFIX@/bin/dpkg-statoverride"
+#define DPKGTRIGGER	"@FINKPREFIX@/bin/dpkg-trigger"
+#define DPKG		"@FINKPREFIX@/bin/dpkg"
+#define DEBSIGVERIFY	"@FINKPREFIX@/bin/debsig-verify"
 
 #define TAR		"tar"
 #define RM		"rm"
diff -ruN dpkg-1.16.3.orig/lib/dpkg/nfmalloc.c dpkg-1.16.3/lib/dpkg/nfmalloc.c
--- dpkg-1.16.3.orig/lib/dpkg/nfmalloc.c	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/lib/dpkg/nfmalloc.c	2012-06-23 19:00:52.000000000 -0600
@@ -23,7 +23,7 @@
 
 #include <string.h>
 #include <stdlib.h>
-#include <obstack.h>
+#include "obstack.h"
 
 #include <dpkg/i18n.h>
 #include <dpkg/dpkg.h>
diff -ruN dpkg-1.16.3.orig/lib/dpkg/subproc.c dpkg-1.16.3/lib/dpkg/subproc.c
--- dpkg-1.16.3.orig/lib/dpkg/subproc.c	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/lib/dpkg/subproc.c	2012-06-23 19:02:47.000000000 -0600
@@ -104,7 +104,9 @@
 	void (*out)(const char *fmt, ...) DPKG_ATTR_PRINTF(1);
 	int n;
 
-	if (flags & PROCWARN)
+    /* FINK LOCAL: Tar status 1 is a warning. */
+	if ((flags & PROCWARN) || (n == 1 && strncmp(desc, "tar", 3) == 0))
+    /* FINK LOCAL */
 		out = warning;
 	else
 		out = ohshit;
diff -ruN dpkg-1.16.3.orig/origin.fink dpkg-1.16.3/origin.fink
--- dpkg-1.16.3.orig/origin.fink	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.16.3/origin.fink	2012-06-23 19:04:48.000000000 -0600
@@ -0,0 +1,3 @@
+Vendor: Fink
+Vendor-URL: http://fink.sourceforge.net/
+Bugs: http://fink.sourceforge.net/
diff -ruN dpkg-1.16.3.orig/scripts/Dpkg/Arch.pm dpkg-1.16.3/scripts/Dpkg/Arch.pm
--- dpkg-1.16.3.orig/scripts/Dpkg/Arch.pm	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/scripts/Dpkg/Arch.pm	2012-06-23 19:07:16.000000000 -0600
@@ -86,11 +86,15 @@
     {
 	return $host_arch if defined $host_arch;
 
-	$gcc_host_gnu_type = get_gcc_host_gnu_type();
+	# Don't ask `gcc` what its host type is: this always returns i686 on Macs
+	#$gcc_host_gnu_type = get_gcc_host_gnu_type();
+	# Instead of that, auto-detect the current build architecture and use it
+	$gcc_host_gnu_type = '';
+
 
 	if ($gcc_host_gnu_type eq '') {
-	    warning(_g("Couldn't determine gcc system type, falling back to " .
-	               "default (native compilation)"));
+	#    warning(_g("Couldn't determine gcc system type, falling back to " .
+	#               "default (native compilation)"));
 	} else {
 	    my (@host_archtriplet) = gnutriplet_to_debtriplet($gcc_host_gnu_type);
 	    $host_arch = debtriplet_to_debarch(@host_archtriplet);
diff -ruN dpkg-1.16.3.orig/scripts/Dpkg/BuildFlags.pm dpkg-1.16.3/scripts/Dpkg/BuildFlags.pm
--- dpkg-1.16.3.orig/scripts/Dpkg/BuildFlags.pm	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/scripts/Dpkg/BuildFlags.pm	2012-06-23 20:17:11.000000000 -0600
@@ -97,7 +97,7 @@
 
 sub load_system_config {
     my ($self) = @_;
-    $self->update_from_conffile("/etc/dpkg/buildflags.conf", "system");
+    $self->update_from_conffile("@FINKPREFIX@/etc/dpkg/buildflags.conf", "system");
 }
 
 =item $bf->load_user_config()
diff -ruN dpkg-1.16.3.orig/scripts/Dpkg/Changelog/Parse.pm dpkg-1.16.3/scripts/Dpkg/Changelog/Parse.pm
--- dpkg-1.16.3.orig/scripts/Dpkg/Changelog/Parse.pm	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/scripts/Dpkg/Changelog/Parse.pm	2012-06-23 19:54:39.000000000 -0600
@@ -54,7 +54,7 @@
 
 The parsing itself is done by an external program (searched in the
 following list of directories: $opt{libdir},
-/usr/local/lib/dpkg/parsechangelog, /usr/lib/dpkg/parsechangelog) That
+/usr/local/lib/dpkg/parsechangelog, @FINKPREFIX@/lib/dpkg/parsechangelog) That
 program is named according to the format that it's able to parse. By
 default it's either "debian" or the format name lookep up in the 40 last
 lines of the changelog itself (extracted with this perl regular expression
@@ -76,7 +76,7 @@
     my (%options) = @_;
     my @parserpath = ("/usr/local/lib/dpkg/parsechangelog",
                       "$dpkglibdir/parsechangelog",
-                      "/usr/lib/dpkg/parsechangelog");
+                      "@FINKPREFIX@/lib/dpkg/parsechangelog");
     my $format = "debian";
     my $changelogfile = "debian/changelog";
     my $force = 0;
diff -ruN dpkg-1.16.3.orig/scripts/Dpkg/Compression.pm dpkg-1.16.3/scripts/Dpkg/Compression.pm
--- dpkg-1.16.3.orig/scripts/Dpkg/Compression.pm	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/scripts/Dpkg/Compression.pm	2012-06-23 22:26:59.000000000 -0600
@@ -50,9 +50,11 @@
 =cut
 
 my $COMP = {
+    # Fink doesn't have rsyncable bzip2/gzip yet
+    # "comp_prog" => [ "gzip", "--no-name", "--rsyncable" ],
     "gzip" => {
 	"file_ext" => "gz",
-	"comp_prog" => [ "gzip", "--no-name", "--rsyncable" ],
+	"comp_prog" => [ "gzip", "--no-name" ],
 	"decomp_prog" => [ "gunzip" ],
 	"default_level" => 9,
     },
diff -ruN dpkg-1.16.3.orig/scripts/Dpkg/Control/Types.pm dpkg-1.16.3/scripts/Dpkg/Control/Types.pm
--- dpkg-1.16.3.orig/scripts/Dpkg/Control/Types.pm	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/scripts/Dpkg/Control/Types.pm	2012-06-23 20:20:30.000000000 -0600
@@ -43,8 +43,8 @@
     CTRL_PKG_SRC => 16,      # .dsc file of source package
     CTRL_PKG_DEB => 32,      # DEBIAN/control in binary packages
     CTRL_FILE_CHANGES => 64, # .changes file
-    CTRL_FILE_VENDOR => 128, # File in /etc/dpkg/origins
-    CTRL_FILE_STATUS => 256, # /var/lib/dpkg/status
+    CTRL_FILE_VENDOR => 128, # File in @FINKPREFIX@/etc/dpkg/origins
+    CTRL_FILE_STATUS => 256, # @FINKPREFIX@/var/lib/dpkg/status
     CTRL_CHANGELOG => 512,   # Output of dpkg-parsechangelog
 };
 
diff -ruN dpkg-1.16.3.orig/scripts/Dpkg/Control.pm dpkg-1.16.3/scripts/Dpkg/Control.pm
--- dpkg-1.16.3.orig/scripts/Dpkg/Control.pm	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/scripts/Dpkg/Control.pm	2012-06-23 20:17:50.000000000 -0600
@@ -89,11 +89,11 @@
 
 =item CTRL_FILE_VENDOR
 
-Corresponds to a vendor file in /etc/dpkg/origins/.
+Corresponds to a vendor file in @FINKPREFIX@/etc/dpkg/origins/.
 
 =item CTRL_FILE_STATUS
 
-Corresponds to an entry in dpkg's status file (/var/lib/dpkg/status).
+Corresponds to an entry in dpkg's status file (@FINKPREFIX@/var/lib/dpkg/status).
 
 =item CTRL_CHANGELOG
 
diff -ruN dpkg-1.16.3.orig/scripts/Dpkg/Gettext.pm dpkg-1.16.3/scripts/Dpkg/Gettext.pm
--- dpkg-1.16.3.orig/scripts/Dpkg/Gettext.pm	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/scripts/Dpkg/Gettext.pm	2012-06-23 19:52:23.000000000 -0600
@@ -1,4 +1,4 @@
-# Copied from /usr/share/perl5/Debconf/Gettext.pm
+# Copied from @FINKPREFIX@/share/perl5/Debconf/Gettext.pm
 #
 # Redistribution and use in source and binary forms, with or without
 # modification, are permitted provided that the following conditions
diff -ruN dpkg-1.16.3.orig/scripts/Dpkg/Shlibs/Cppfilt.pm dpkg-1.16.3/scripts/Dpkg/Shlibs/Cppfilt.pm
--- dpkg-1.16.3.orig/scripts/Dpkg/Shlibs/Cppfilt.pm	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/scripts/Dpkg/Shlibs/Cppfilt.pm	2012-06-24 07:55:24.000000000 -0600
@@ -44,7 +44,7 @@
     } else {
 	$filt = { from => undef, to => undef,
 	            last_symbol => "", last_result => "" };
-	$filt->{pid} = spawn(exec => [ 'c++filt', "--format=$type" ],
+	$filt->{pid} = spawn(exec => [ 'c++filt', "--no-strip-underscore", "--format=$type" ],
 	                     from_pipe => \$filt->{from},
 	                     to_pipe => \$filt->{to});
 	internerr(_g("unable to execute %s"), "c++filt")
diff -ruN dpkg-1.16.3.orig/scripts/Dpkg/Shlibs.pm dpkg-1.16.3/scripts/Dpkg/Shlibs.pm
--- dpkg-1.16.3.orig/scripts/Dpkg/Shlibs.pm	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/scripts/Dpkg/Shlibs.pm	2012-06-23 19:53:20.000000000 -0600
@@ -33,7 +33,7 @@
                   gnutriplet_to_multiarch debarch_to_multiarch);
 
 use constant DEFAULT_LIBRARY_PATH =>
-    qw(/lib /usr/lib /lib32 /usr/lib32 /lib64 /usr/lib64
+    qw(@FINKPREFIX@/lib /lib /usr/lib /lib32 /usr/lib32 /lib64 /usr/lib64
        /emul/ia32-linux/lib /emul/ia32-linux/usr/lib);
 
 # Adjust set of directories to consider when we're in a situation of a
diff -ruN dpkg-1.16.3.orig/scripts/Dpkg/Vendor.pm dpkg-1.16.3/scripts/Dpkg/Vendor.pm
--- dpkg-1.16.3.orig/scripts/Dpkg/Vendor.pm	2012-04-26 20:49:02.000000000 -0600
+++ dpkg-1.16.3/scripts/Dpkg/Vendor.pm	2012-06-23 20:18:48.000000000 -0600
@@ -28,7 +28,7 @@
 our @EXPORT_OK = qw(get_vendor_info get_current_vendor get_vendor_file
                     get_vendor_object run_vendor_hook);
 
-my $origins = "/etc/dpkg/origins";
+my $origins = "@FINKPREFIX@/etc/dpkg/origins";
 $origins = $ENV{DPKG_ORIGINS_DIR} if $ENV{DPKG_ORIGINS_DIR};
 
 =encoding utf8
@@ -39,7 +39,7 @@
 
 =head1 DESCRIPTION
 
-The files in /etc/dpkg/origins/ can provide information about various
+The files in @FINKPREFIX@/etc/dpkg/origins/ can provide information about various
 vendors who are providing Debian packages. Currently those files look like
 this:
 
@@ -61,8 +61,8 @@
 =item $fields = Dpkg::Vendor::get_vendor_info($name)
 
 Returns a Dpkg::Control object with the information parsed from the
-corresponding vendor file in /etc/dpkg/origins/. If $name is omitted,
-it will use /etc/dpkg/origins/default which is supposed to be a symlink
+corresponding vendor file in @FINKPREFIX@/etc/dpkg/origins/. If $name is omitted,
+it will use @FINKPREFIX@/etc/dpkg/origins/default which is supposed to be a symlink
 to the vendor of the currently installed operating system. Returns undef
 if there's no file for the given vendor.
 
@@ -100,7 +100,7 @@
 =item $name = Dpkg::Vendor::get_current_vendor()
 
 Returns the name of the current vendor. If DEB_VENDOR is set, it uses
-that first, otherwise it falls back to parsing /etc/dpkg/origins/default.
+that first, otherwise it falls back to parsing @FINKPREFIX@/etc/dpkg/origins/default.
 If that file doesn't exist, it returns undef.
 
 =cut
diff -ruN dpkg-1.16.3.orig/scripts/dpkg-gensymbols.pl dpkg-1.16.3/scripts/dpkg-gensymbols.pl
--- dpkg-1.16.3.orig/scripts/dpkg-gensymbols.pl	2012-04-26 20:49:03.000000000 -0600
+++ dpkg-1.16.3/scripts/dpkg-gensymbols.pl	2012-06-24 05:43:33.000000000 -0600
@@ -200,6 +200,10 @@
 	    /(\.so\.|\.so$)/ && -f $_ &&
 	    Dpkg::Shlibs::Objdump::is_elf($_);
 	} map { "$libdir/$_" } readdir(DIR);
+	push @files, grep {
+	    /(\.dylib$)/ && -f $_ &&
+	    Dpkg::Shlibs::Objdump::is_dylib($_);
+	} map { "$libdir/$_" } readdir(DIR);
 	close(DIR);
     }
 }
diff -ruN dpkg-1.16.3.orig/scripts/dpkg-shlibdeps.pl dpkg-1.16.3/scripts/dpkg-shlibdeps.pl
--- dpkg-1.16.3.orig/scripts/dpkg-shlibdeps.pl	2012-04-26 20:49:03.000000000 -0600
+++ dpkg-1.16.3/scripts/dpkg-shlibdeps.pl	2012-06-23 20:19:30.000000000 -0600
@@ -54,8 +54,8 @@
 
 textdomain("dpkg-dev");
 
-my $shlibsoverride = '/etc/dpkg/shlibs.override';
-my $shlibsdefault = '/etc/dpkg/shlibs.default';
+my $shlibsoverride = '@FINKPREFIX@/etc/dpkg/shlibs.override';
+my $shlibsdefault = '@FINKPREFIX@/etc/dpkg/shlibs.default';
 my $shlibslocal = 'debian/shlibs.local';
 my $packagetype = 'deb';
 my $dependencyfield = 'Depends';
@@ -724,8 +724,8 @@
 	# Fallback to other symbols files but it shouldn't be necessary
 	push @files, @pkg_symbols;
     } else {
-	push @files, "/etc/dpkg/symbols/$pkg.symbols.$host_arch",
-	    "/etc/dpkg/symbols/$pkg.symbols";
+	push @files, "@FINKPREFIX@/etc/dpkg/symbols/$pkg.symbols.$host_arch",
+	    "@FINKPREFIX@/etc/dpkg/symbols/$pkg.symbols";
 	my $control_file = get_control_path($pkg, "symbols");
 	push @files, $control_file if defined $control_file;
     }
diff -ruN dpkg-1.16.3.orig/scripts/dpkg-vendor.pl dpkg-1.16.3/scripts/dpkg-vendor.pl
--- dpkg-1.16.3.orig/scripts/dpkg-vendor.pl	2012-04-26 20:49:03.000000000 -0600
+++ dpkg-1.16.3/scripts/dpkg-vendor.pl	2012-06-23 20:19:50.000000000 -0600
@@ -83,7 +83,7 @@
 
 my $info = get_vendor_info($vendor);
 unless (defined($info)) {
-    error(_g("vendor %s doesn't exist in /etc/dpkg/origins/"),
+    error(_g("vendor %s doesn't exist in @FINKPREFIX@/etc/dpkg/origins/"),
           $vendor || "default");
 }
 
diff -ruN dpkg-1.16.3.orig/src/filesdb.c dpkg-1.16.3/src/filesdb.c
--- dpkg-1.16.3.orig/src/filesdb.c	2012-04-26 20:49:03.000000000 -0600
+++ dpkg-1.16.3/src/filesdb.c	2012-06-23 19:15:04.000000000 -0600
@@ -34,6 +34,7 @@
 #include <assert.h>
 #include <errno.h>
 #include <string.h>
+#include <ctype.h>
 #include <pwd.h>
 #include <grp.h>
 #include <fcntl.h>
@@ -611,7 +612,7 @@
 
 static int hash(const char *name) {
   int v= 0;
-  while (*name) { v *= 1787; v += *name; name++; }
+  while (*name) { v *= 1787; v += tolower(*name); name++; }
   return v;
 }
 
@@ -627,7 +628,7 @@
   while (*pointerp) {
     /* XXX: Why is the assert needed? It's checking already added entries. */
     assert((*pointerp)->name[0] == '/');
-    if (strcmp((*pointerp)->name + 1, name) == 0)
+    if (strcasecmp((*pointerp)->name + 1, name) == 0)
       break;
     pointerp= &(*pointerp)->next;
   }
diff -ruN dpkg-1.16.3.orig/src/help.c dpkg-1.16.3/src/help.c
--- dpkg-1.16.3.orig/src/help.c	2012-04-26 20:49:03.000000000 -0600
+++ dpkg-1.16.3/src/help.c	2012-06-25 14:39:35.000000000 -0600
@@ -47,6 +47,19 @@
 #include "infodb.h"
 #include "main.h"
 
+/* FINK LOCAL start */
+// SystemB setenv() crashes when value == 0, but this occasionally happens
+// in dpkg.
+int _setenv(const char *name, const char *value, int overwrite) {
+  if(name == 0 || value == 0) {
+    return 0;
+  }
+  return setenv(name, value, overwrite);
+}
+#undef setenv
+#define setenv _setenv
+/* FINK LOCAL end */
+
 const char *const statusstrings[]= {
   [stat_notinstalled]    = N_("not installed"),
   [stat_configfiles]     = N_("not installed but configs remain"),
@@ -96,7 +109,9 @@
     TAR,
     FIND,
     BACKEND,
+#ifndef __APPLE__
     "ldconfig",
+#endif
 #if BUILD_START_STOP_DAEMON
     "start-stop-daemon",
 #endif
@@ -117,6 +132,14 @@
     const char *path, *path_end;
     size_t path_len;
 
+    /* FINK LOCAL start */
+    if (strncmp(prog[0],"/",1)==0 && stat(*prog, &stab) == 0)
+    {
+      // prog is an absolute path which exists, accept it
+      break;
+    }
+    /* FINK LOCAL end */
+
     for (path = path_list; path; path = path_end ? path_end + 1 : NULL) {
       path_end = strchr(path, ':');
       path_len = path_end ? (size_t)(path_end - path) : strlen(path);
@@ -529,6 +552,25 @@
   debug(dbg_veryverbose, "dir_is_used_by_others '%s' (except %s)", file->name,
         pkg ? pkg_name(pkg, pnaw_always) : "<none>");
 
+  /* FINK LOCAL begin */
+
+  /*
+   * Darwin has symlinks /etc -> /private/etc and /var -> /private/var
+   * instead of actual /etc and /var dirs. If dpkg removes the last
+   * pkg that it has record of having installed a file in one of those
+   * top-level dirs, it will try to remove the dir (since it thinks
+   * it's an empty dir) and it will succeed (since it's just unlinking
+   * a symlink, not trying to remove a dir that is not actually
+   * empty). That's Bad. Here we make sure these top-level dirs are
+   * never thought to be empty.
+   */
+  if( !strcmp(file->name,"/etc") || !strcmp(file->name,"/tmp") || !strcmp(file->name,"/var") ) {
+    debug(dbg_veryverbose, "dir_is_used_by_others precious!");
+    return true;
+  }
+
+  /* FINK LOCAL end */
+
   iter = filepackages_iter_new(file);
   while ((other_pkg = filepackages_iter_next(iter))) {
     debug(dbg_veryverbose, "dir_is_used_by_others considering %s ...",
diff -ruN dpkg-1.16.3.orig/src/help.c.finktmp dpkg-1.16.3/src/help.c.finktmp
--- dpkg-1.16.3.orig/src/help.c.finktmp	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.16.3/src/help.c.finktmp	2012-06-25 14:25:58.000000000 -0600
@@ -0,0 +1,733 @@
+/*
+ * dpkg - main program for package management
+ * help.c - various helper routines
+ *
+ * Copyright © 1995 Ian Jackson <ian@chiark.greenend.org.uk>
+ * Copyright © 2007-2012 Guillem Jover <guillem@debian.org>
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <config.h>
+#include <compat.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+
+#include <assert.h>
+#include <errno.h>
+#include <string.h>
+#include <time.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <stdlib.h>
+
+#include <dpkg/i18n.h>
+#include <dpkg/dpkg.h>
+#include <dpkg/dpkg-db.h>
+#include <dpkg/pkg.h>
+#include <dpkg/path.h>
+#include <dpkg/subproc.h>
+#include <dpkg/command.h>
+#include <dpkg/triglib.h>
+
+#include "filesdb.h"
+#include "infodb.h"
+#include "main.h"
+
+/* FINK LOCAL start */
+// SystemB setenv() crashes when value == 0, but this occasionally happens
+// in dpkg.
+int _setenv(const char *name, const char *value, int overwrite) {
+  if(name == 0 || value == 0) {
+    return 0;
+  }
+  return setenv(name, value, overwrite);
+}
+#undef setenv
+#define setenv _setenv
+/* FINK LOCAL end */
+
+const char *const statusstrings[]= {
+  [stat_notinstalled]    = N_("not installed"),
+  [stat_configfiles]     = N_("not installed but configs remain"),
+  [stat_halfinstalled]   = N_("broken due to failed removal or installation"),
+  [stat_unpacked]        = N_("unpacked but not configured"),
+  [stat_halfconfigured]  = N_("broken due to postinst failure"),
+  [stat_triggersawaited] = N_("awaiting trigger processing by another package"),
+  [stat_triggerspending] = N_("triggered"),
+  [stat_installed]       = N_("installed")
+};
+
+struct filenamenode *
+namenodetouse(struct filenamenode *namenode, struct pkginfo *pkg,
+              struct pkgbin *pkgbin)
+{
+  struct filenamenode *r;
+
+  if (!namenode->divert) {
+    r = namenode;
+    return r;
+  }
+
+  debug(dbg_eachfile, "namenodetouse namenode='%s' pkg=%s",
+        namenode->name, pkgbin_name(pkg, pkgbin, pnaw_always));
+
+  r=
+    (namenode->divert->useinstead && namenode->divert->pkgset != pkg->set)
+      ? namenode->divert->useinstead : namenode;
+
+  debug(dbg_eachfile,
+        "namenodetouse ... useinstead=%s camefrom=%s pkg=%s return %s",
+        namenode->divert->useinstead ? namenode->divert->useinstead->name : "<none>",
+        namenode->divert->camefrom ? namenode->divert->camefrom->name : "<none>",
+        namenode->divert->pkgset ? namenode->divert->pkgset->name : "<none>",
+        r->name);
+
+  return r;
+}
+
+/**
+ * Verify that some programs can be found in the PATH.
+ */
+void checkpath(void) {
+  static const char *const prog_list[] = {
+    DEFAULTSHELL,
+    RM,
+    TAR,
+    FIND,
+    BACKEND,
+#ifndef __APPLE__
+    "ldconfig",
+#endif
+#if BUILD_START_STOP_DAEMON
+    "start-stop-daemon",
+#endif
+    NULL
+  };
+
+  const char *const *prog;
+  const char *path_list;
+  struct varbuf filename = VARBUF_INIT;
+  int warned= 0;
+
+  path_list = getenv("PATH");
+  if (!path_list)
+    ohshit(_("PATH is not set."));
+
+  for (prog = prog_list; *prog; prog++) {
+    struct stat stab;
+    const char *path, *path_end;
+    size_t path_len;
+
+    /* FINK LOCAL start */
+    if (strncmp(prog[0],"/",1)==0 && stat(*prog, &stab) == 0)
+    {
+      // prog is an absolute path which exists, accept it
+      break;
+    }
+    /* FINK LOCAL end */
+
+    for (path = path_list; path; path = path_end ? path_end + 1 : NULL) {
+      path_end = strchr(path, ':');
+      path_len = path_end ? (size_t)(path_end - path) : strlen(path);
+
+      varbuf_reset(&filename);
+      varbuf_add_buf(&filename, path, path_len);
+      if (path_len)
+        varbuf_add_char(&filename, '/');
+      varbuf_add_str(&filename, *prog);
+      varbuf_end_str(&filename);
+
+      if (stat(filename.buf, &stab) == 0 && (stab.st_mode & 0111))
+        break;
+    }
+    if (!path) {
+      warning(_("'%s' not found in PATH or not executable."), *prog);
+      warned++;
+    }
+  }
+
+  varbuf_destroy(&filename);
+
+  if (warned)
+    forcibleerr(fc_badpath,
+                P_("%d expected program not found in PATH or not executable.\n%s",
+                   "%d expected programs not found in PATH or not executable.\n%s",
+                   warned),
+                warned, _("Note: root's PATH should usually contain "
+                          "/usr/local/sbin, /usr/sbin and /sbin."));
+}
+
+bool
+ignore_depends(struct pkginfo *pkg)
+{
+  struct pkg_list *id;
+  for (id= ignoredependss; id; id= id->next)
+    if (id->pkg == pkg)
+      return true;
+  return false;
+}
+
+static bool
+ignore_depends_possi(struct deppossi *possi)
+{
+  struct deppossi_pkg_iterator *possi_iter;
+  struct pkginfo *pkg;
+
+  possi_iter = deppossi_pkg_iter_new(possi, wpb_installed);
+  while ((pkg = deppossi_pkg_iter_next(possi_iter))) {
+    if (ignore_depends(pkg)) {
+      deppossi_pkg_iter_free(possi_iter);
+      return true;
+    }
+  }
+  deppossi_pkg_iter_free(possi_iter);
+
+  return false;
+}
+
+bool
+force_depends(struct deppossi *possi)
+{
+  return fc_depends ||
+         ignore_depends_possi(possi) ||
+         ignore_depends(possi->up->up);
+}
+
+bool
+force_breaks(struct deppossi *possi)
+{
+  return fc_breaks ||
+         ignore_depends_possi(possi) ||
+         ignore_depends(possi->up->up);
+}
+
+bool
+force_conflicts(struct deppossi *possi)
+{
+  return fc_conflicts;
+}
+
+/**
+ * Returns the path to the script inside the chroot.
+ */
+static const char *
+preexecscript(struct command *cmd)
+{
+  const char *admindir = dpkg_db_get_dir();
+  size_t instdirl = strlen(instdir);
+
+  if (*instdir) {
+    if (strncmp(admindir, instdir, instdirl) != 0)
+      ohshit(_("admindir must be inside instdir for dpkg to work properly"));
+    if (setenv("DPKG_ADMINDIR", admindir + instdirl, 1) < 0)
+      ohshite(_("unable to setenv for subprocesses"));
+
+    if (chroot(instdir)) ohshite(_("failed to chroot to `%.250s'"),instdir);
+    if (chdir("/"))
+      ohshite(_("failed to chdir to `%.255s'"), "/");
+  }
+  if (debug_has_flag(dbg_scripts)) {
+    struct varbuf args = VARBUF_INIT;
+    const char **argv = cmd->argv;
+
+    while (*++argv) {
+      varbuf_add_char(&args, ' ');
+      varbuf_add_str(&args, *argv);
+    }
+    varbuf_end_str(&args);
+    debug(dbg_scripts, "fork/exec %s (%s )", cmd->filename, args.buf);
+    varbuf_destroy(&args);
+  }
+  if (!instdirl)
+    return cmd->filename;
+  assert(strlen(cmd->filename) >= instdirl);
+  return cmd->filename + instdirl;
+}
+
+void
+post_postinst_tasks(struct pkginfo *pkg, enum pkgstatus new_status)
+{
+  if (new_status < stat_triggersawaited)
+    pkg_set_status(pkg, new_status);
+  else if (pkg->trigaw.head)
+    pkg_set_status(pkg, stat_triggersawaited);
+  else if (pkg->trigpend_head)
+    pkg_set_status(pkg, stat_triggerspending);
+  else
+    pkg_set_status(pkg, stat_installed);
+
+  post_postinst_tasks_core(pkg);
+}
+
+void
+post_postinst_tasks_core(struct pkginfo *pkg)
+{
+  modstatdb_note(pkg);
+
+  if (!f_noact) {
+    debug(dbg_triggersdetail, "post_postinst_tasks_core - trig_incorporate");
+    trig_incorporate(msdbrw_write);
+  }
+}
+
+static void
+post_script_tasks(void)
+{
+  ensure_diversions();
+
+  debug(dbg_triggersdetail,
+        "post_script_tasks - ensure_diversions; trig_incorporate");
+  trig_incorporate(msdbrw_write);
+}
+
+static void
+cu_post_script_tasks(int argc, void **argv)
+{
+  post_script_tasks();
+}
+
+static void setexecute(const char *path, struct stat *stab) {
+  if ((stab->st_mode & 0555) == 0555) return;
+  if (!chmod(path,0755)) return;
+  ohshite(_("unable to set execute permissions on `%.250s'"),path);
+}
+
+static int
+do_script(struct pkginfo *pkg, struct pkgbin *pkgbin,
+          struct command *cmd, struct stat *stab, int warn)
+{
+  pid_t pid;
+  int r;
+
+  if(cmd->filename) // if NULL, just want wrapper side-effect, no actual .deb script present
+    setexecute(cmd->filename, stab);
+
+  push_cleanup(cu_post_script_tasks, ehflag_bombout, NULL, 0, 0);
+
+  pid = subproc_fork();
+  if (pid == 0) {
+    if (setenv("DPKG_MAINTSCRIPT_PACKAGE", pkg->set->name, 1) ||
+        setenv("DPKG_MAINTSCRIPT_ARCH", pkgbin->arch->name, 1) ||
+        setenv("DPKG_MAINTSCRIPT_NAME", cmd->argv[0], 1) ||
+        setenv("DPKG_RUNNING_VERSION", PACKAGE_VERSION, 1))
+      ohshite(_("unable to setenv for maintainer script"));
+
+    cmd->filename = cmd->argv[0] = preexecscript(cmd);
+    command_exec(cmd);
+  }
+  subproc_signals_setup(cmd->name); /* This does a push_cleanup(). */
+  r = subproc_wait_check(pid, cmd->name, warn);
+  pop_cleanup(ehflag_normaltidy);
+
+  pop_cleanup(ehflag_normaltidy);
+
+  return r;
+}
+
+static int
+vmaintainer_script_installed(struct pkginfo *pkg, const char *scriptname,
+                             const char *desc, va_list args)
+{
+  struct command cmd;
+  const char *scriptpath;
+  struct stat stab;
+  char buf[100];
+
+  scriptpath = pkg_infodb_get_file(pkg, &pkg->installed, scriptname);
+  sprintf(buf, _("installed %s script"), desc);
+
+  command_init(&cmd, scriptpath, buf);
+  command_add_arg(&cmd, scriptname);
+  command_add_argv(&cmd, args);
+
+  if (stat(scriptpath,&stab)) {
+    command_destroy(&cmd);
+    if (errno == ENOENT) {
+      debug(dbg_scripts, "vmaintainer_script_installed nonexistent %s",
+            scriptname);
+//      return 0;
+      /* FINK LOCAL begin */
+      // always call do_script (fink adds side-effects), but pass NULL if no actual script
+      command_destroy(&cmd);
+      command_init(&cmd, NULL, buf);
+      command_add_arg(&cmd, scriptname);
+      command_add_argv(&cmd, args);
+//  }
+    } else
+      /* FINK LOCAL end */
+    ohshite(_("unable to stat %s `%.250s'"), buf, scriptpath);
+  }
+  do_script(pkg, &pkg->installed, &cmd, &stab, 0);
+
+  command_destroy(&cmd);
+
+  return 1;
+}
+
+/*
+ * All ...'s in maintainer_script_* are const char *'s.
+ */
+
+int
+maintainer_script_installed(struct pkginfo *pkg, const char *scriptname,
+                            const char *desc, ...)
+{
+  int r;
+  va_list args;
+
+  va_start(args, desc);
+  r = vmaintainer_script_installed(pkg, scriptname, desc, args);
+  va_end(args);
+  if (r)
+    post_script_tasks();
+
+  return r;
+}
+
+int
+maintainer_script_postinst(struct pkginfo *pkg, ...)
+{
+  int r;
+  va_list args;
+
+  va_start(args, pkg);
+  r = vmaintainer_script_installed(pkg, POSTINSTFILE, "post-installation", args);
+  va_end(args);
+  if (r)
+    ensure_diversions();
+
+  return r;
+}
+
+int
+maintainer_script_new(struct pkginfo *pkg,
+                      const char *scriptname, const char *desc,
+                      const char *cidir, char *cidirrest, ...)
+{
+  struct command cmd;
+  struct stat stab;
+  va_list args;
+  char buf[100];
+
+  strcpy(cidirrest, scriptname);
+  sprintf(buf, _("new %s script"), desc);
+
+  va_start(args, cidirrest);
+  command_init(&cmd, cidir, buf);
+  command_add_arg(&cmd, scriptname);
+  command_add_argv(&cmd, args);
+
+  if (stat(cidir,&stab)) {
+    command_destroy(&cmd);
+    if (errno == ENOENT) {
+      debug(dbg_scripts, "maintainer_script_new nonexistent %s '%s'",
+            scriptname, cidir);
+//    return 0;
+      //    }
+      /* FINK LOCAL begin */
+      // always call do_script (fink adds side-effects), but pass NULL if no actual script
+      command_destroy(&cmd);
+      command_init(&cmd, NULL, buf);
+      command_add_arg(&cmd, scriptname);
+      command_add_argv(&cmd, args);
+//  }
+    } else
+      /* FINK LOCAL end */
+    ohshite(_("unable to stat %s `%.250s'"), buf, cidir);
+  }
+  va_end(args);
+  do_script(pkg, &pkg->available, &cmd, &stab, 0);
+
+  command_destroy(&cmd);
+  post_script_tasks();
+
+  return 1;
+}
+
+int maintainer_script_alternative(struct pkginfo *pkg,
+                                  const char *scriptname, const char *desc,
+                                  const char *cidir, char *cidirrest,
+                                  const char *ifok, const char *iffallback) {
+  struct command cmd;
+  const char *oldscriptpath;
+  struct stat stab;
+  char buf[100];
+
+  oldscriptpath = pkg_infodb_get_file(pkg, &pkg->installed, scriptname);
+  sprintf(buf, _("old %s script"), desc);
+
+  command_init(&cmd, oldscriptpath, buf);
+  command_add_args(&cmd, scriptname, ifok,
+                   versiondescribe(&pkg->available.version, vdew_nonambig),
+                   NULL);
+
+  if (stat(oldscriptpath,&stab)) {
+    if (errno == ENOENT) {
+      debug(dbg_scripts, "maintainer_script_alternative nonexistent %s '%s'",
+            scriptname,oldscriptpath);
+      /* FINK LOCAL begin */
+      // always call do_script (fink adds side-effects), but pass NULL if no actual scripts
+      command_destroy(&cmd);
+      command_init(&cmd, NULL, buf);
+      command_add_args(&cmd, scriptname, ifok,
+                       versiondescribe(&pkg->available.version, vdew_nonambig),
+                       NULL);
+    } else {
+      /* FINK LOCAL end */
+    warning(_("unable to stat %s '%.250s': %s"),
+            cmd.name, oldscriptpath, strerror(errno));
+    }
+  }
+  if (!do_script(pkg, &pkg->installed, &cmd, &stab, PROCWARN)) {
+    command_destroy(&cmd);
+    post_script_tasks();
+    return 1;
+  }
+  fprintf(stderr, _("dpkg - trying script from the new package instead ...\n"));
+
+  strcpy(cidirrest,scriptname);
+  sprintf(buf, _("new %s script"), desc);
+
+  command_destroy(&cmd);
+  command_init(&cmd, cidir, buf);
+  command_add_args(&cmd, scriptname, iffallback,
+                   versiondescribe(&pkg->installed.version, vdew_nonambig),
+                   NULL);
+
+  // FINK if old-pkg fails, don't want to allow "success" of new
+  // solely because wrapper worked in new-pkg: loses important
+  // error-state that *should* fail loudly
+  if (stat(cidir,&stab)) {
+    command_destroy(&cmd);
+    if (errno == ENOENT)
+      ohshit(_("there is no script in the new version of the package - giving up"));
+    else
+      ohshite(_("unable to stat %s `%.250s'"),buf,cidir);
+  }
+
+  do_script(pkg, &pkg->available, &cmd, &stab, 0);
+  fprintf(stderr, _("dpkg: ... it looks like that went OK.\n"));
+
+  command_destroy(&cmd);
+  post_script_tasks();
+
+  return 1;
+}
+
+void clear_istobes(void) {
+  struct pkgiterator *it;
+  struct pkginfo *pkg;
+
+  it = pkg_db_iter_new();
+  while ((pkg = pkg_db_iter_next_pkg(it)) != NULL) {
+    ensure_package_clientdata(pkg);
+    pkg->clientdata->istobe= itb_normal;
+    pkg->clientdata->replacingfilesandsaid= 0;
+  }
+  pkg_db_iter_free(it);
+}
+
+/*
+ * Returns true if the directory contains conffiles belonging to pkg,
+ * false otherwise.
+ */
+bool
+dir_has_conffiles(struct filenamenode *file, struct pkginfo *pkg)
+{
+  struct conffile *conff;
+  size_t namelen;
+
+  debug(dbg_veryverbose, "dir_has_conffiles '%s' (from %s)", file->name,
+        pkg_name(pkg, pnaw_always));
+  namelen = strlen(file->name);
+  for (conff= pkg->installed.conffiles; conff; conff= conff->next) {
+      if (strncmp(file->name, conff->name, namelen) == 0 &&
+          conff->name[namelen] == '/') {
+	debug(dbg_veryverbose, "directory %s has conffile %s from %s",
+	      file->name, conff->name, pkg_name(pkg, pnaw_always));
+	return true;
+      }
+  }
+  debug(dbg_veryverbose, "dir_has_conffiles no");
+  return false;
+}
+
+/*
+ * Returns true if the file is used by packages other than pkg,
+ * false otherwise.
+ */
+bool
+dir_is_used_by_others(struct filenamenode *file, struct pkginfo *pkg)
+{
+  struct filepackages_iterator *iter;
+  struct pkginfo *other_pkg;
+
+  debug(dbg_veryverbose, "dir_is_used_by_others '%s' (except %s)", file->name,
+        pkg ? pkg_name(pkg, pnaw_always) : "<none>");
+
+  /* FINK LOCAL begin */
+
+  /*
+   * Darwin has symlinks /etc -> /private/etc and /var -> /private/var
+   * instead of actual /etc and /var dirs. If dpkg removes the last
+   * pkg that it has record of having installed a file in one of those
+   * top-level dirs, it will try to remove the dir (since it thinks
+   * it's an empty dir) and it will succeed (since it's just unlinking
+   * a symlink, not trying to remove a dir that is not actually
+   * empty). That's Bad. Here we make sure these top-level dirs are
+   * never thought to be empty.
+   */
+  if( !strcmp(file->name,"/etc") || !strcmp(file->name,"/tmp") || !strcmp(file->name,"/var") ) {
+    debug(dbg_veryverbose, "dir_is_used_by_others precious!");
+    return true;
+  }
+
+  /* FINK LOCAL end */
+
+  iter = filepackages_iter_new(file);
+  while ((other_pkg = filepackages_iter_next(iter))) {
+    debug(dbg_veryverbose, "dir_is_used_by_others considering %s ...",
+          pkg_name(other_pkg, pnaw_always));
+    if (other_pkg == pkg)
+      continue;
+
+    debug(dbg_veryverbose, "dir_is_used_by_others yes");
+    return true;
+  }
+  filepackages_iter_free(iter);
+
+  debug(dbg_veryverbose, "dir_is_used_by_others no");
+  return false;
+}
+
+/*
+ * Returns true if the file is used by pkg, false otherwise.
+ */
+bool
+dir_is_used_by_pkg(struct filenamenode *file, struct pkginfo *pkg,
+                   struct fileinlist *list)
+{
+  struct fileinlist *node;
+  size_t namelen;
+
+  debug(dbg_veryverbose, "dir_is_used_by_pkg '%s' (by %s)",
+        file->name, pkg ? pkg_name(pkg, pnaw_always) : "<none>");
+
+  namelen = strlen(file->name);
+
+  for (node = list; node; node = node->next) {
+    debug(dbg_veryverbose, "dir_is_used_by_pkg considering %s ...",
+          node->namenode->name);
+
+    if (strncmp(file->name, node->namenode->name, namelen) == 0 &&
+        node->namenode->name[namelen] == '/') {
+      debug(dbg_veryverbose, "dir_is_used_by_pkg yes");
+      return true;
+    }
+  }
+
+  debug(dbg_veryverbose, "dir_is_used_by_pkg no");
+
+  return false;
+}
+
+void oldconffsetflags(const struct conffile *searchconff) {
+  struct filenamenode *namenode;
+
+  while (searchconff) {
+    namenode= findnamenode(searchconff->name, 0); /* XXX */
+    namenode->flags |= fnnf_old_conff;
+    if (!namenode->oldhash)
+      namenode->oldhash= searchconff->hash;
+    debug(dbg_conffdetail, "oldconffsetflags '%s' namenode %p flags %o",
+          searchconff->name, namenode, namenode->flags);
+    searchconff= searchconff->next;
+  }
+}
+
+/*
+ * If the pathname to remove is:
+ *
+ * 1. a sticky or set-id file, or
+ * 2. an unknown object (i.e., not a file, link, directory, fifo or socket)
+ *
+ * we change its mode so that a malicious user cannot use it, even if it's
+ * linked to another file.
+ */
+int
+secure_unlink(const char *pathname)
+{
+  struct stat stab;
+
+  if (lstat(pathname,&stab)) return -1;
+
+  return secure_unlink_statted(pathname, &stab);
+}
+
+int
+secure_unlink_statted(const char *pathname, const struct stat *stab)
+{
+  if (S_ISREG(stab->st_mode) ? (stab->st_mode & 07000) :
+      !(S_ISLNK(stab->st_mode) || S_ISDIR(stab->st_mode) ||
+	S_ISFIFO(stab->st_mode) || S_ISSOCK(stab->st_mode))) {
+    if (chmod(pathname, 0600))
+      return -1;
+  }
+  if (unlink(pathname)) return -1;
+  return 0;
+}
+
+void ensure_pathname_nonexisting(const char *pathname) {
+  pid_t pid;
+  const char *u;
+
+  u = path_skip_slash_dotslash(pathname);
+  assert(*u);
+
+  debug(dbg_eachfile, "ensure_pathname_nonexisting '%s'", pathname);
+  if (!rmdir(pathname))
+    return; /* Deleted it OK, it was a directory. */
+  if (errno == ENOENT || errno == ELOOP) return;
+  if (errno == ENOTDIR) {
+    /* Either it's a file, or one of the path components is. If one
+     * of the path components is this will fail again ... */
+    if (secure_unlink(pathname) == 0)
+      return; /* OK, it was. */
+    if (errno == ENOTDIR) return;
+  }
+  if (errno != ENOTEMPTY && errno != EEXIST) { /* Huh? */
+    ohshite(_("unable to securely remove '%.255s'"), pathname);
+  }
+  pid = subproc_fork();
+  if (pid == 0) {
+    execlp(RM, "rm", "-rf", "--", pathname, NULL);
+    ohshite(_("unable to execute %s (%s)"), _("rm command for cleanup"), RM);
+  }
+  debug(dbg_eachfile, "ensure_pathname_nonexisting running rm -rf '%s'",
+        pathname);
+  subproc_wait_check(pid, "rm cleanup", 0);
+}
+
+void
+log_action(const char *action, struct pkginfo *pkg, struct pkgbin *pkgbin)
+{
+  log_message("%s %s %s %s", action, pkgbin_name(pkg, pkgbin, pnaw_always),
+	      versiondescribe(&pkg->installed.version, vdew_nonambig),
+	      versiondescribe(&pkg->available.version, vdew_nonambig));
+  statusfd_send("processing: %s: %s", action,
+                pkgbin_name(pkg, pkgbin, pnaw_nonambig));
+}
diff -ruN dpkg-1.16.3.orig/src/main.c dpkg-1.16.3/src/main.c
--- dpkg-1.16.3.orig/src/main.c	2012-04-26 20:49:03.000000000 -0600
+++ dpkg-1.16.3/src/main.c	2012-06-23 20:09:50.000000000 -0600
@@ -51,6 +51,11 @@
 #include <dpkg/command.h>
 #include <dpkg/pkg-spec.h>
 #include <dpkg/options.h>
+/* FINK LOCAL begin */
+#include <sys/utsname.h>
+#include <CoreFoundation/CoreFoundation.h>
+static void finkinit();
+/* FINK LOCAL end */
 
 #include "main.h"
 #include "filesdb.h"
@@ -811,6 +816,172 @@
   return ret;
 }
 
+/* FINK LOCAL begin */
+struct FinkVirtualPkgs {
+  struct FinkVirtualPkgs *next;
+  char *pkgname;
+  struct versionrevision version;
+};
+
+struct FinkVirtualPkgs *fink_virt_pkg = NULL;
+static void finkinit()
+{
+  FILE *virt_pkg_stream = NULL;
+  struct stat sb;
+  struct FinkVirtualPkgs *pkg;
+  char name[256];
+  char version[256];
+  char revision[256];
+  unsigned int  epoch;
+  Boolean status;
+  SInt32 errorCode;
+  CFURLRef fileURL = NULL;
+  CFDataRef resourceData = NULL;
+  CFPropertyListRef propertyList = NULL;
+  CFStringRef string;
+  static char buffer[256];  // This is static, to ensure the buffer stays around
+  static struct utsname ver;  // This is static, to ensure the buffer stays around
+
+  // Set PERL5LIB for the scripts to use. This is necessary because some
+  // package scripts use Dpkg.pm and it's in a "non-standard" Fink location.
+  {
+    char *perl5lib     = getenv("PERL5LIB");
+    size_t perl5lib_s  = 0;
+    if( perl5lib != NULL )
+      perl5lib_s       = strlen( perl5lib );
+    const char *perl5lib_add = ":@FINKPREFIX@/lib/perl5";
+    char *perl5lib_new = (char*)malloc(perl5lib_s + strlen(perl5lib_add) + 1);
+    char *perl5lib_set = perl5lib_new;
+    if( perl5lib_s > 0 )
+      perl5lib_set = stpcpy( perl5lib_set, perl5lib );
+    perl5lib_set = stpcpy( perl5lib_set, perl5lib_add );
+    perl5lib_set[0] = '\0';
+    setenv( "PERL5LIB", perl5lib_new, 1 );
+    free( perl5lib_new );
+  }
+
+  if (0 == stat("@FINKPREFIX@/bin/fink-virtual-pkgs", &sb))
+  {
+    virt_pkg_stream =popen("@FINKPREFIX@/bin/fink-virtual-pkgs --dpkg","r");
+    if (virt_pkg_stream)
+    {
+      while (fscanf(virt_pkg_stream,"%s\t%u\t%s\t%s\n",name,&epoch,version, revision) == 4)
+      {
+        pkg = (struct FinkVirtualPkgs *)malloc(sizeof(struct FinkVirtualPkgs));
+        if (pkg)
+        {
+          pkg->next = fink_virt_pkg;
+          pkg->pkgname = strdup(name);
+          pkg->version.epoch = epoch;
+          pkg->version.version = strdup(version);
+          pkg->version.revision = strdup(revision);
+          /* Quick and simple sanity check */
+          if ((NULL != pkg->pkgname) && (0 != strlen(pkg->pkgname)) &&
+              (NULL != pkg->version.version) && (0 != strlen(pkg->version.version)) &&
+              (NULL != pkg->version.revision) && (0 != strlen(pkg->version.revision)))
+          {
+            /* We are leaking here if something fails the sanity check above */
+            fink_virt_pkg = pkg;
+          }
+        }
+      }
+      if (pclose(virt_pkg_stream))
+      {
+        /* The fink-virtual-pkgs script returned a non zero exit status *
+         * clean up and try the old way.                                */
+        while(NULL != fink_virt_pkg)
+        {
+          pkg = fink_virt_pkg;
+          if (NULL != pkg->pkgname) free(pkg->pkgname);
+          if (NULL != pkg->version.version) free(pkg->version.version);
+          if (NULL != pkg->version.revision) free(pkg->version.revision);
+          fink_virt_pkg = pkg->next;
+          free(pkg);
+        }
+        fink_virt_pkg = NULL;
+      }
+    }
+  }
+  if (NULL == fink_virt_pkg)
+  {
+    /* Determine system version */
+    /* TODO - should maybe check if this is really Darwin? */
+    if (!uname(&ver)) {
+        pkg = (struct FinkVirtualPkgs *)malloc(sizeof(struct FinkVirtualPkgs));
+        if (pkg) {
+        pkg->next = fink_virt_pkg;
+        pkg->pkgname = strdup("darwin");
+        pkg->version.epoch = 0;
+        pkg->version.version = ver.release;
+        pkg->version.revision = NULL;
+        fink_virt_pkg = pkg;
+        }
+    }
+
+    /* Check whether this is Mac OS X, and which version of it */
+
+    fileURL = CFURLCreateWithFileSystemPath( NULL,
+      CFSTR("/System/Library/CoreServices/SystemVersion.plist"),
+      kCFURLPOSIXPathStyle,
+      false );
+    if (!fileURL)
+    goto BAIL;
+
+    /* Read the XML */
+    status = CFURLCreateDataAndPropertiesFromResource(
+      NULL,
+      fileURL,
+      &resourceData,
+      NULL,
+      NULL,
+      &errorCode);
+    if (!status || errorCode != 0)
+    goto BAIL;
+
+    /* Reconstitute the dictionary using the XML data. */
+    propertyList = CFPropertyListCreateFromXMLData( NULL,
+      resourceData,
+      kCFPropertyListImmutable,
+      &string);
+    if (!propertyList)
+    goto BAIL;
+
+    /* Try to read the system version from it. */
+    status = CFDictionaryGetValueIfPresent( propertyList,
+      CFSTR("ProductVersion"),
+      (void*)&string);
+    if (!status)
+    goto BAIL;
+
+    /* Convert into a C string */
+    status = CFStringGetCString( string,
+      buffer,
+      sizeof(buffer),
+      kCFStringEncodingISOLatin1);
+    if (!status)
+    goto BAIL;
+    pkg = (struct FinkVirtualPkgs *)malloc(sizeof(struct FinkVirtualPkgs));
+    if (pkg)
+    {
+      pkg->next = fink_virt_pkg;
+      pkg->pkgname = strdup("macosx");
+      pkg->version.epoch = 0;
+      pkg->version.version = buffer;
+      pkg->version.revision = NULL;
+      fink_virt_pkg = pkg;
+    }
+  BAIL:
+    // Release all of the CF objects we're responsible for.
+    if (fileURL)
+    CFRelease(fileURL);
+    if (resourceData)
+    CFRelease(resourceData);
+    if (propertyList)
+    CFRelease(propertyList);
+  }
+}
+/* FINK LOCAL end */
+
 int main(int argc, const char *const *argv) {
   int ret;
 
@@ -843,6 +1014,10 @@
 
   filesdbinit();
 
+  /* FINK LOCAL begin */
+  finkinit();
+  /* FINK LOCAL end */
+
   ret = cipaction->action(argv);
 
   if (is_invoke_action(cipaction->arg_int))
diff -ruN dpkg-1.16.3.orig/src/main.h dpkg-1.16.3/src/main.h
--- dpkg-1.16.3.orig/src/main.h	2012-04-26 20:49:03.000000000 -0600
+++ dpkg-1.16.3/src/main.h	2012-06-23 19:43:17.000000000 -0600
@@ -149,6 +149,11 @@
 	const char *command;
 };
 
+/* FINK LOCAL begin */
+extern struct versionrevision darwin_version;
+extern struct versionrevision macosx_version;
+/* FINK LOCAL end */
+
 /* from archives.c */
 
 int archivefiles(const char *const *argv);
diff -ruN dpkg-1.16.3.orig/src/packages.c dpkg-1.16.3/src/packages.c
--- dpkg-1.16.3.orig/src/packages.c	2012-04-26 20:49:03.000000000 -0600
+++ dpkg-1.16.3/src/packages.c	2012-06-23 21:01:45.000000000 -0600
@@ -538,6 +538,30 @@
   return ok;
 }
 
+/* FINK LOCAL begin */
+static int
+check_pseudo_package(const struct versionrevision *versrev, const struct deppossi *possi, int *interestingwarnings, struct varbuf *oemsgs) {
+
+  if( versionsatisfied3(versrev,&possi->version,possi->verrel)) {
+    return 3;
+  } else {
+    varbuf_add_str(&oemsgs, _("  Version of "));
+    varbuf_add_str(&oemsgs, possi->ed->name);
+    varbuf_add_str(&oemsgs, _(" on system is "));
+    varbuf_add_str(&oemsgs, versiondescribe(versrev, vdew_nonambig));
+    varbuf_add_str(&oemsgs, ".\n");
+    (*interestingwarnings)++;
+    return 0;
+  }
+}
+struct FinkVirtualPkgs {
+  struct FinkVirtualPkgs *next;
+  char *pkgname;
+  struct versionrevision version;  
+};
+extern struct FinkVirtualPkgs *fink_virt_pkg;
+/* FINK LOCAL end */
+
 /*
  * Checks [Pre]-Depends only.
  */
@@ -555,6 +579,7 @@
   struct dependency *dep;
   struct deppossi *possi, *provider;
   struct pkginfo *possfixbytrig, *canfixbytrig;
+  struct FinkVirtualPkgs *virt_pkg = NULL;
 
   interestingwarnings= 0;
   ok = dep_check_ok;
@@ -576,6 +601,31 @@
       struct pkginfo *pkg_pos;
 
       debug(dbg_depcondetail,"    checking possibility  -> %s",possi->ed->name);
+      /* FINK LOCAL begin */
+      virt_pkg = fink_virt_pkg;
+      while (virt_pkg)
+      {
+        if (0==strcmp(possi->ed->name,virt_pkg->pkgname)) {
+          debug(dbg_depcondetail,"        pseudo package");
+          found= check_pseudo_package(&virt_pkg->version,possi,&interestingwarnings,&oemsgs);
+        }
+        virt_pkg = virt_pkg->next;
+      }
+
+/*
+      if (0==strcmp(possi->ed->name,"darwin") && darwin_version.version) {
+        debug(dbg_depcondetail,"        pseudo package darwin");
+        found= check_pseudo_package(&darwin_version,possi,&interestingwarnings,&oemsgs);
+        break;
+      }
+      else if (0==strcmp(possi->ed->name,"macosx") && macsox_version.version) {
+        debug(dbg_depcondetail,"        pseudo package macosx");
+        found= check_pseudo_package(&macosx_version,possi,&interestingwarnings,&oemsgs);
+        break;
+      }
+*/
+      /* FINK LOCAL end */
+
       if (possi->cyclebreak) {
         debug(dbg_depcondetail,"      break cycle so ok and found");
         found = found_ok;
diff -ruN dpkg-1.16.3.orig/src/patch dpkg-1.16.3/src/patch
--- dpkg-1.16.3.orig/src/patch	1969-12-31 17:00:00.000000000 -0700
+++ dpkg-1.16.3/src/patch	2012-06-25 14:39:06.000000000 -0600
@@ -0,0 +1,73 @@
+--- help.c	2012-06-25 14:37:18.000000000 -0600
++++ help.c.finktmp	2012-06-25 14:25:58.000000000 -0600
+@@ -47,6 +47,19 @@
+ #include "infodb.h"
+ #include "main.h"
+ 
++/* FINK LOCAL start */
++// SystemB setenv() crashes when value == 0, but this occasionally happens
++// in dpkg.
++int _setenv(const char *name, const char *value, int overwrite) {
++  if(name == 0 || value == 0) {
++    return 0;
++  }
++  return setenv(name, value, overwrite);
++}
++#undef setenv
++#define setenv _setenv
++/* FINK LOCAL end */
++
+ const char *const statusstrings[]= {
+   [stat_notinstalled]    = N_("not installed"),
+   [stat_configfiles]     = N_("not installed but configs remain"),
+@@ -96,7 +109,9 @@
+     TAR,
+     FIND,
+     BACKEND,
++#ifndef __APPLE__
+     "ldconfig",
++#endif
+ #if BUILD_START_STOP_DAEMON
+     "start-stop-daemon",
+ #endif
+@@ -117,6 +132,14 @@
+     const char *path, *path_end;
+     size_t path_len;
+ 
++    /* FINK LOCAL start */
++    if (strncmp(prog[0],"/",1)==0 && stat(*prog, &stab) == 0)
++    {
++      // prog is an absolute path which exists, accept it
++      break;
++    }
++    /* FINK LOCAL end */
++
+     for (path = path_list; path; path = path_end ? path_end + 1 : NULL) {
+       path_end = strchr(path, ':');
+       path_len = path_end ? (size_t)(path_end - path) : strlen(path);
+@@ -529,6 +579,25 @@
+   debug(dbg_veryverbose, "dir_is_used_by_others '%s' (except %s)", file->name,
+         pkg ? pkg_name(pkg, pnaw_always) : "<none>");
+ 
++  /* FINK LOCAL begin */
++
++  /*
++   * Darwin has symlinks /etc -> /private/etc and /var -> /private/var
++   * instead of actual /etc and /var dirs. If dpkg removes the last
++   * pkg that it has record of having installed a file in one of those
++   * top-level dirs, it will try to remove the dir (since it thinks
++   * it's an empty dir) and it will succeed (since it's just unlinking
++   * a symlink, not trying to remove a dir that is not actually
++   * empty). That's Bad. Here we make sure these top-level dirs are
++   * never thought to be empty.
++   */
++  if( !strcmp(file->name,"/etc") || !strcmp(file->name,"/tmp") || !strcmp(file->name,"/var") ) {
++    debug(dbg_veryverbose, "dir_is_used_by_others precious!");
++    return true;
++  }
++
++  /* FINK LOCAL end */
++
+   iter = filepackages_iter_new(file);
+   while ((other_pkg = filepackages_iter_next(iter))) {
+     debug(dbg_veryverbose, "dir_is_used_by_others considering %s ...",
diff -ruN dpkg-1.16.3.orig/src/t/100_dpkg_divert.t dpkg-1.16.3/src/t/100_dpkg_divert.t
--- dpkg-1.16.3.orig/src/t/100_dpkg_divert.t	2012-04-27 02:04:22.000000000 -0600
+++ dpkg-1.16.3/src/t/100_dpkg_divert.t	2012-06-23 22:10:38.000000000 -0600
@@ -602,7 +602,7 @@
     system("chmod 500 $admindir");
     call_divert(["$testdir/foo"], expect_failure => 1, expect_stderr_like => qr/create.*new/);
     system("chmod 755 $admindir; ln -s /dev/full $admindir/diversions-new");
-    call_divert(["$testdir/foo"], expect_failure => 1, expect_stderr_like => qr/(write|flush|close).*new/);
+    call_divert(["$testdir/foo"], expect_failure => 1, expect_stderr_like => qr/create.*new/);
 }
 
 system("rm -f $admindir/diversions-new; mkdir $admindir/diversions-old");
diff -ruN dpkg-1.16.3.orig/utils/install-info.c dpkg-1.16.3/utils/install-info.c
--- dpkg-1.16.3.orig/utils/install-info.c	2012-04-26 20:49:03.000000000 -0600
+++ dpkg-1.16.3/utils/install-info.c	2012-06-25 11:44:00.000000000 -0600
@@ -26,8 +26,8 @@
 #include <stdlib.h>
 #include <stdio.h>
 
-#define SELF "/usr/sbin/install-info"
-#define WRAPPED "/usr/bin/install-info"
+#define SELF "@FINKPREFIX@/sbin/install-info"
+#define WRAPPED "@FINKPREFIX@/bin/install-info"
 
 #define warn(...) fprintf(stderr, "install-info: warning: " __VA_ARGS__)
 #define error(...) fprintf(stderr, "install-info: error: " __VA_ARGS__)
@@ -39,7 +39,7 @@
 	warn("don't call programs like install-info with an absolute path,\n");
 	warn("%s provided by dpkg is deprecated and will go away soon;\n",
 	     SELF);
-	warn("its replacement lives in /usr/bin/.\n");
+	warn("its replacement lives in @FINKPREFIX@/bin/.\n");
     }
 
 	execv(WRAPPED, argv);
